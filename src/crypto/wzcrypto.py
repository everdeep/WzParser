import math
from enum import Enum

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

# fmt: off
MAPLESTORY_KEY_DEFAULT = [
    0x13, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x5B, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
    0xB4, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x1B, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
    0x0F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00,
    0x33, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
    0x52, 0x00, 0x00, 0x00, 0xDE, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00
]
# fmt: on

MAPLESTORY_GMS_IV = [0x4D, 0x23, 0xC7, 0x2B]
MAPLESTORY_EMS_IV = [0xB9, 0x7D, 0x63, 0xE9]
MAPLESTORY_BMS_IV = [0x00, 0x00, 0x00, 0x00]
MAPLESTORY_CLASSIC_IV = [0x00, 0x00, 0x00, 0x00]
MAPLESTORY_GENERATE_IV = [0x00, 0x00, 0x00, 0x00]


class WzIv(Enum):
    GMS = MAPLESTORY_GMS_IV
    EMS = MAPLESTORY_EMS_IV
    BMS = MAPLESTORY_BMS_IV
    Classic = MAPLESTORY_CLASSIC_IV
    Generate = MAPLESTORY_GENERATE_IV


class WzKey:
    def __init__(self, iv: WzIv = WzIv.GMS, key=MAPLESTORY_KEY_DEFAULT):
        self.version = iv.name
        self.iv = iv.value

        self.key = bytearray(32)
        for i in range(0, 128, 16):
            self.key[i // 4] = key[i]

        self.cipher = bytearray(0)

    def ensure_size(self, n):
        if len(self.cipher) >= n:
            return

        encryptor = Cipher(algorithms.AES(self.key), modes.ECB()).encryptor()

        for i in range(len(self.cipher), math.ceil(n / 16) * 16, 16):
            if i == 0:
                block = bytearray(16)
                for j in range(16):
                    block[j] = self.iv[j % 4]
            else:
                block = self.cipher[-16:]

            self.cipher.extend(encryptor.update(block))

    def at(self, i):
        self.ensure_size(i + 1)
        return self.cipher[i]

    def __setitem__(self, i, value):
        self.ensure_size(i + 1)
        self.cipher[i] = value

    # def __str__(self) -> str:
    #     print("WzKey(iv={}, key={})".format(self.iv, self.key))

    # def __repr__(self) -> str:
    #     return str(self)
